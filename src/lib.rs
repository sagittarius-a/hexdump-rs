use std::str;

#[allow(dead_code)]
fn to_format_hex(elements: &[u8], separator_index: usize) -> String {
    let mut hex = String::new();
    for (i, element) in elements.iter().enumerate() {
        hex += &format!("{:02x}", element);
        hex += " ";
        if separator_index > 1 && separator_index - 1 == i {
            hex += " ";
        }
    }
    if !hex.is_empty() {
        return hex[..hex.len() - 1].to_string();
    }
    hex
}

#[allow(dead_code)]
fn to_format_ascii(elements: &[u8]) -> String {
    let mut ascii = String::new();
    for element in elements {
        if element.is_ascii_alphanumeric() || element.is_ascii_punctuation() || *element == 0x20 {
            ascii += str::from_utf8(&[*element]).unwrap();
        } else {
            ascii += ".";
        }
    }
    ascii
}

#[allow(dead_code)]
pub fn hexdump(content: String, length: usize) -> String {
    let mut hexdump = String::new();
    let mut offset = 0;
    let step = length;
    let width = 3 * length;

    for chunk in content.as_bytes().chunks(step) {
        let l: Vec<u8> = chunk.to_vec();
        hexdump += &format!(
            "{:08x}|  {: <width$}  |{}|",
            offset,
            to_format_hex(l.as_slice(), (length as u64 as f64 / 2.0).floor() as usize),
            to_format_ascii(l.as_slice()),
            width = width
        );
        offset += step;
        hexdump += "\n"
    }
    hexdump
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn to_format_hex_test() {
        assert_eq!(
            to_format_hex("AAAABBBBCCCC".as_bytes(), 6),
            "41 41 41 41 42 42  42 42 43 43 43 43"
        );
        assert_eq!(
            to_format_hex("AAAABBBBCCCC".as_bytes(), 0),
            "41 41 41 41 42 42 42 42 43 43 43 43"
        );
    }
    #[test]
    fn to_format_ascii_all_ascii() {
        assert_eq!(to_format_ascii("ABCD".as_bytes()), "ABCD");
    }

    #[test]
    fn to_format_ascii_digits() {
        assert_eq!(to_format_ascii("1234".as_bytes()), "1234");
    }

    #[test]

    fn to_format_ascii_not_all_ascii() {
        assert_eq!(to_format_ascii("A\tC\n".as_bytes()), "A.C.");
    }

    #[test]

    fn to_format_ascii_utf8() {
        assert_eq!(to_format_ascii("A❤C❤".as_bytes()), "A...C...");
    }

    #[test]
    fn basic_hexdump_16() {
        assert_eq!(
            hexdump("AAAABBBBCCCCDDDDEEEEFFFF".to_string(), 16),
            concat!(
                "00000000|  41 41 41 41 42 42 42 42  43 43 43 43 44 44 44 44  |AAAABBBBCCCCDDDD|\n",
                "00000010|  45 45 45 45 46 46 46 46                           |EEEEFFFF|\n"
            )
        );
    }

    #[test]
    fn basic_hexdump_8() {
        assert_eq!(
            hexdump("AAAABBBBCCCCD".to_string(), 8),
            concat!(
                "00000000|  41 41 41 41  42 42 42 42  |AAAABBBB|\n",
                "00000008|  43 43 43 43  44           |CCCCD|\n"
            )
        );
    }

    #[test]
    fn basic_hexdump_4() {
        assert_eq!(
            hexdump("AAAABBBB".to_string(), 4),
            concat!(
                "00000000|  41 41  41 41  |AAAA|\n",
                "00000004|  42 42  42 42  |BBBB|\n",
            )
        );
    }

    #[test]
    fn basic_hexdump_file_16() {
        let string = r#"# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
[[package]]
name = "hexdump"
version = "0.1.0"
"#;
        assert_eq!(
            hexdump(string.to_string(), 16),
            concat!(
                "00000000|  23 20 54 68 69 73 20 66  69 6c 65 20 69 73 20 61  |# This file is a|\n",
                "00000010|  75 74 6f 6d 61 74 69 63  61 6c 6c 79 20 40 67 65  |utomatically @ge|\n",
                "00000020|  6e 65 72 61 74 65 64 20  62 79 20 43 61 72 67 6f  |nerated by Cargo|\n",
                "00000030|  2e 0a 23 20 49 74 20 69  73 20 6e 6f 74 20 69 6e  |..# It is not in|\n",
                "00000040|  74 65 6e 64 65 64 20 66  6f 72 20 6d 61 6e 75 61  |tended for manua|\n",
                "00000050|  6c 20 65 64 69 74 69 6e  67 2e 0a 5b 5b 70 61 63  |l editing..[[pac|\n",
                "00000060|  6b 61 67 65 5d 5d 0a 6e  61 6d 65 20 3d 20 22 68  |kage]].name = \"h|\n",
                "00000070|  65 78 64 75 6d 70 22 0a  76 65 72 73 69 6f 6e 20  |exdump\".version |\n",
                "00000080|  3d 20 22 30 2e 31 2e 30  22 0a                    |= \"0.1.0\".|\n",
            )
        );
    }
}
